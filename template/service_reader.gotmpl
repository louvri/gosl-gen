{{- $packageName := toLower .Table.Name }}
package reader

import (
    "context"
    "strings"

    "github.com/go-kit/log"
    "github.com/go-kit/log/level"
    base "$PROJECT_PATH/$REPOSITORY_PATH"
    "$PROJECT_PATH/internal/model/request/{{$packageName}}/search"
    db "$PROJECT_PATH/$MODEL_PATH/{{$packageName}}"
    "github.com/louvri/gosl/builder"
    "github.com/louvri/gob/str"
    "$PROJECT_PATH/driver"
)

type service struct {
	logger log.Logger
    repository base.Repository
}

type Service interface{
    Search(ctx context.Context, request search.Request) ([]db.Model, error)
    Count(ctx context.Context, request search.Request) (int64, error)
}


func New(repo base.Repository, logger log.Logger) Service {
	return &service{
		logger: logger,
		repository:   repo,
	}
}


func (s *service) Search(ctx context.Context, request search.Request) ([]db.Model, error) {
    params, err := s.buildRequest(request)
    if err != nil {
		level.Error(driver.Instance().Logger()).Log("{{$packageName}}:service:reader:search", err)
		return nil, err
	}
    if request.Transformer != nil {
        _, err := s.repository.Query(ctx, params, nil, *request.Transformer)
		if err != nil {
			level.Error(driver.Instance().Logger()).Log(err.Error())
		}
		return nil, err
    }

    data, err := s.repository.Query(ctx, params, nil)
	if err != nil {
		level.Error(driver.Instance().Logger()).Log(err.Error())
	}
	if data == nil {
		return nil, nil
	}
	return data.([]db.Model), err
}

func (s *service) Count(ctx context.Context, request search.Request) (int64, error) {
    params, err := s.buildRequest(request)
	if err != nil {
		level.Error(driver.Instance().Logger()).Log("{{$packageName}}:service:reader:count", err)
		return 0, err
	}
	total, err := s.repository.Count(ctx, params, nil)
	if err != nil {
		level.Error(driver.Instance().Logger()).Log(err.Error())
	}
	return total, err
}

func (s *service) buildRequest(request search.Request) (query []builder.QueryParams, err error) {
    create := func(request search.Request) builder.QueryParams {
        result := builder.QueryParams{}
        if request.Paging.Orderby != "" {
			orderby := make(map[string]interface{})
			for _, item := range str.SplitOnNotEmpty(request.Paging.Orderby, ",") {
				token := strings.Split(item, ":")
				if len(token) > 1 {
					orderby[token[0]] = token[1]
				} else {
					orderby[token[0]] = "asc"
				}
			}
			result.Orderby = orderby
		}
        if request.Paging.Page != 0 {
			result.Page = request.Paging.Page
		}
		if request.Paging.Next != 0 {
			result.Next = request.Paging.Next
		}
		if request.Paging.Size != 0 {
			result.Size = request.Paging.Size
		}

		tmp := request.Body.ToDBModel()
		result.Object = tmp.ToMap(nil)
		return result
    }
    return []builder.QueryParams{
		create(request),
	}, nil
}